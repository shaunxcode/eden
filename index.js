// Generated by CoffeeScript 1.3.3
(function() {
  var $, addToEnv, eden, edn, parseTag, prepTags, reactive, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  $ = require("jquery");

  _ = require("underscore");

  edn = require("jsedn");

  reactive = require("reactive");

  parseTag = function(str, defaultTag) {
    var bindTo, i, id, k, klass, rest, tag, _i, _len, _ref, _ref1, _ref2;
    bindTo = {
      id: false,
      "class": [],
      tag: false
    };
    if (__indexOf.call(str, "#") >= 0) {
      _ref = str.split("#"), tag = _ref[0], rest = _ref[1];
      if (!tag.length) {
        tag = defaultTag;
      }
      _ref1 = rest.split("."), id = _ref1[0], klass = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
    } else if (__indexOf.call(str, ".") >= 0) {
      id = false;
      _ref2 = str.split("."), tag = _ref2[0], klass = 2 <= _ref2.length ? __slice.call(_ref2, 1) : [];
      if (!tag.length) {
        tag = defaultTag;
      }
    } else {
      tag = str;
      id = false;
      klass = false;
    }
    if (id[0] === "@") {
      bindTo.id = true;
      id = id.slice(1);
    }
    if (tag[0] === "@") {
      bindTo.tag = true;
      tag = tag.slice(1);
    }
    for (i = _i = 0, _len = klass.length; _i < _len; i = ++_i) {
      k = klass[i];
      if (k[0] === "@") {
        klass[i] = k.slice(1);
        bindTo["class"].push(klass[i]);
      }
    }
    return {
      tagName: tag,
      "class": klass,
      id: id,
      bindTo: bindTo,
      options: {}
    };
  };

  addToEnv = function(env, key, val) {
    if (!(env[key] != null)) {
      env[key] = $();
    }
    return env[key] = env[key].add(val);
  };

  prepTags = function(taglist, defaultTag) {
    var last, prepped, t, _i, _len;
    prepped = [];
    last = false;
    for (_i = 0, _len = taglist.length; _i < _len; _i++) {
      t = taglist[_i];
      if (_.isArray(t)) {
        prepped.push(last = prepTags(t));
      } else if ((!_.isArray(t)) && _.isObject(t)) {
        if (!last) {
          throw "trying to apply options without a prior element";
        }
        last.options = t;
      } else {
        prepped.push(last = parseTag(t, defaultTag));
      }
    }
    return prepped;
  };

  eden = function(str, options, onCreate) {
    var appendTo, elAttrs, env, handleTags, k, reifyOptions, rootTag, tags, v, _ref;
    if (options == null) {
      options = {};
    }
    if (_.isFunction(options)) {
      options = {
        onCreate: options
      };
    }
    if (_.isFunction(onCreate)) {
      options.onCreate = onCreate;
    }
    options.onCreate || (options.onCreate = function() {});
    options.appendTo || (options.appendTo = false);
    options.defaultTag || (options.defaultTag = "div");
    options.self || (options.self = {});
    if (str[0] !== "[") {
      str = "[" + str + "]";
    }
    elAttrs = {};
    for (k in options) {
      v = options[k];
      if (k !== "appendTo" && k !== "onCreate" && k !== "defaultTag" && k !== "self" && k !== "reactTo") {
        elAttrs[k] = v;
      }
    }
    env = {};
    tags = [];
    reifyOptions = function(options, env, path) {
      var key, part, reified, result, val, value, _i, _len, _ref;
      if (path == null) {
        path = [];
      }
      result = {};
      for (key in options) {
        value = options[key];
        key = key.replace(/\:/g, "");
        if (_.isObject(value)) {
          reified = reifyOptions(value, env, path.concat([key]));
          if (_.size(reified)) {
            result[key] = reified;
          }
        } else if (value[0] === "@") {
          val = env;
          _ref = value.slice(1).split(".");
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            val = val[part];
          }
          if (_.isFunction(val)) {
            val = _.bind(val, env);
          }
          result[key] = val;
        } else {
          result[key] = value;
        }
      }
      return result;
    };
    handleTags = function(tagList, appendTo, isRoot) {
      var $tag, arrOptions, klass, reified, tag, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      if (isRoot == null) {
        isRoot = false;
      }
      arrOptions = tagList.options || {};
      for (_i = 0, _len = tagList.length; _i < _len; _i++) {
        tag = tagList[_i];
        if (_.isArray(tag)) {
          handleTags(tag, $tag);
        } else {
          reified = reifyOptions(_.extend(tag.options, elAttrs, arrOptions), options.self);
          tags.push($tag = $("<" + tag.tagName + "/>", reified));
          if (isRoot) {
            appendTo = appendTo.add($tag);
          } else {
            appendTo.append($tag);
          }
          addToEnv(env, tag.tagName, $tag);
          if (tag["class"]) {
            $tag.addClass(tag["class"].join(" "));
            _ref = tag["class"];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              klass = _ref[_j];
              addToEnv(env, klass, $tag);
            }
          }
          if (tag.id) {
            $tag.attr({
              id: tag.id
            });
            addToEnv(env, tag.id, $tag);
          }
          if (tag.bindTo.id) {
            options.self["$" + tag.id] = $tag;
          }
          _ref1 = tag.bindTo["class"];
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            k = _ref1[_k];
            options.self["$" + k] = $tag;
          }
          if (tag.bindTo.tag) {
            options.self["$" + tag.tagName] = $tag;
          }
        }
      }
      return appendTo;
    };
    appendTo = options.appendTo;
    if (_.isString(appendTo)) {
      appendTo = $(appendTo);
    }
    rootTag = handleTags(prepTags(edn.toJS(edn.parse(str)), options.defaultTag), appendTo || $(), appendTo === false);
    env._ = options.self;
    if ((_ref = options.onCreate) != null) {
      _ref.apply(env, tags);
    }
    if (options.reactTo) {
      reactive(rootTag[0], options.reactTo);
    }
    return rootTag;
  };

  module.exports = eden;

}).call(this);
